# **1.8 每日一题**

#### [89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)

难度中等408收藏分享切换为英文接收动态反馈

**n 位格雷码序列** 是一个由 `2n` 个整数组成的序列，其中：

- 每个整数都在范围 `[0, 2n - 1]` 内（含 `0` 和 `2n - 1`）
- 第一个整数是 `0`
- 一个整数在序列中出现 **不超过一次**
- 每对 **相邻** 整数的二进制表示 **恰好一位不同** ，且
- **第一个** 和 **最后一个** 整数的二进制表示 **恰好一位不同**

给你一个整数 `n` ，返回任一有效的 **n 位格雷码序列** 。

 

**示例 1：**

```
输入：n = 2
输出：[0,1,3,2]
解释：
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。
- 00 和 01 有一位不同
- 01 和 11 有一位不同
- 11 和 10 有一位不同
- 10 和 00 有一位不同
[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- 00 和 10 有一位不同
- 10 和 11 有一位不同
- 11 和 01 有一位不同
- 01 和 00 有一位不同
```

**示例 2：**

```
输入：n = 1
输出：[0,1]
```

 

**提示：**

- `1 <= n <= 16`





## 第一次尝试

```python
class Solution:
    def grayCode(self, n: int) -> List[int]:
        result = [0 for i in range(2**n)]
        print(result)
        for i in range(2**n):
            result[i] = (i >> 1) ^ i
        print(result) 
        return result
```



这个是根据题解学会的,但是真的没有理解  result[i] = (i >> 1) ^ i 这个公式怎么来的

根据网上找到的, 应该是格雷编码的公式

一个数字对应的格雷编码的计算方式是:

- 将其二进制第一位(从高位数)与0异或, 得到的结果为格雷码的第一位
- 之后依次将原数的第i位与生成的格雷码第i-1位做异或运算, 即可得到格雷码的第i位.

添加备注

执行用时：56 ms, 在所有 Python3 提交中击败了38.06%的用户

内存消耗：18.2 MB, 在所有 Python3 提交中击败了53.76%的用户

通过测试用例：16 / 16



## 第二次尝试

```python
class Solution:
    def grayCode(self, n: int) -> List[int]:
        if n == 1:
            return [0, 1]
        result = [0,1]
        head = 1
        while head != n:
            temp = result.copy()
            temp.reverse()
            print(temp)
            for i in temp:
                result.append((1 << head) + i)
            print("here is result %s " %(result))
            head += 1
        return result
```

这个就是找规律发现的

比如 n = 1 一定是 [0, 1]

这是一个base case

然后看 n = 2, 是[0, 1, 3, 2]

我们能发现是前面一半是和 n - 1一样的

然后看后面 是前面 一半 + 2 [1, 0] $\rightarrow$ [1+ 2, 0 + 2] + $\rightarrow$ [3, 2]

所以我们得到 n = 2时, 结果是 [0,1,3,2]

就得到这个了

执行结果：

通过

显示详情



添加备注

执行用时：56 ms, 在所有 Python3 提交中击败了38.06%的用户

内存消耗：18.2 MB, 在所有 Python3 提交中击败了53.76%的用户

通过测试用例：16 / 16



## 第三次尝试

准备尝试递归